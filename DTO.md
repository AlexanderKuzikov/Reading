# Почему нужно использовать DTO

Data Transfer Object — термин, который для разработчиков на статических языках является чем-то само собой разумеющимся, но остальные его могут не знать (даже если пользуются). Однако в эпоху интеграций (фронтенд-бекенд, сервис-сервис, очереди) это крайне важная конструкция.

## Что такое DTO?

DTO — это промежуточный объект между моделью в вашем коде и данными, которые вы отдаёте наружу или принимаете от внешней системы.

```
Модель ⇄ DTO ⇄ json/protobuf/sql/...
```

## Почему не преобразовывать напрямую?

На первый взгляд можно превратить JSON сразу в модель или наоборот, используя встроенные механизмы с метаданными и аннотациями:

```java
@Entity
public class User {
    @Id
    private Long id;
    @JsonIgnore              // приходится скрывать
    private String passwordHash;
    @JsonProperty("created_at")
    private LocalDateTime createdAt;
    // getters/setters ...
}
var json = new ObjectMapper().writeValueAsString(dto);
```

Но это плохая идея. Это нарушает архитектуру MVC — модель начинает знать о представлении, о том какие поля выдавать наружу, какие скрывать, как их переименовывать и так далее.

## Реальные проблемы

**Множественные представления одной сущности**

Одна и та же сущность редко представляется для внешнего мира одним способом. В зависимости от задачи — один набор полей или другой.

**Утечка деталей реализации**

Легко может быть, что новое поле автоматически попало наружу, хотя вы этого не планировали, но забыли его исключить.

**Загрязнение модели**

Если нужны вычисляемые поля или другое представление (например, всегда единая дата), модель будет наполняться дополнительными свойствами и методами, которые готовят данные для преобразования. Что из этого относится к бизнес-части, а что к представлению? Проблема.

## Преимущества DTO

**Отделение представления от модели**

DTO создают промежуточный слой, позволяя независимо развивать модель и API для взаимодействия с ней. Это один из аспектов MVC — конкретно Model-View.

**Генерация типов**

Готовые DTO гораздо легче конвертировать в типы TypeScript. Например, DTO (используя Alba) превращаются в типы TS с помощью готовых инструментов (Typelizer). С моделями так легко не получится.

## Стоимость

В проекте появится папка с большим количеством файлов. Но это с лихвой компенсирует описанные выше проблемы. DTO очень простые — для их создания далеко не всегда надо писать классы с нуля. В Java они генерируются с помощью MapStruct, в других языках свои механизмы.

## Автоматическая генерация

Это только базовая история. Если подключить инструменты генерации из SQL (как в Go) или OpenAPI (везде), DTO создаются автоматически на основе описаний.

### Пример с sqlc

Библиотека генерирует DTO на базе запроса и схемы базы:

**Запрос:**
```sql
INSERT INTO links (original_url, short_name)
VALUES (sqlc.arg(original_url), sqlc.arg(short_name))
RETURNING *;
```

**Генерированный DTO:**
```go
type CreateLinkParams struct {
    OriginalUrl string `json:"original_url"`
    ShortName   string `json:"short_name"`
}
```

**Для update создаётся отдельная структура:**
```go
type UpdateLinkParams struct {
    OriginalUrl string `json:"original_url"`
    ShortName   string `json:"short_name"`
    ID          int64  `json:"id"`
}
```

Отличия в создании и обновлении одной сущности обычно значительны, поэтому количество DTO растёт, но каждый остаётся простым и сфокусированным.

## Важно

**DTO должны быть имутабельны**, иначе туда потечёт логика.

---

*P.S. Вы сами пишете DTO или генерируете?*
